# -*- coding: utf-8 -*-
"""
/***************************************************************************
 InventoryValidator
                                 A QGIS plugin
 Umożliwia sprawdzenie poprawności plików shp przekazywanych przez wykonawcę
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-01-26
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Łukasz Słowik
        email                : slowik.lukasz1988@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QTimer
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QMessageBox, QFileDialog
from qgis.core import QgsVectorLayer, NULL
from zipfile import ZipFile

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .inventory_validator_dialog import InventoryValidatorDialog
from .dlg_errors import DlgErrors
import os.path
import csv
import time
import glob


# 4. LISTS WITH FIES NAMES (P1, P2, ...)
def fns_from_paths(paths):
    fns = []
    for path in paths:
        name = os.path.basename(path)[:-4]
        if name not in fns:
            fns.append(name)
            
    return fns

# 5. COMPARE LAYERS NAMES WITH TEMPLATES
def names_check(inv_fns, templ_fns):
    name_errors = []
    for ifn in inv_fns:
        if ifn not in templ_fns:
            name_errors.append(ifn)
    
    return name_errors


# 6. DELETE PATHS TO FILES WITH WRONG NAMES
def remove_wrong_paths(inv_paths, name_errors):
#    if len(name_errors) > 0: # sprawdzone w treści klasy - i tak generowana jest informacja
    for err in name_errors:
        for path in inv_paths:
            if os.path.basename(path)[:-4] == err:
                inv_paths.remove(path)
                
    return inv_paths


# 7. LIST 2D WITH FIELDS PARAMETERS FROM TOC
def attribute_table_structure(paths):
    attr_struct = []
    for path in paths:
        name = os.path.basename(path)[:-4]
        layer = QgsVectorLayer(path, name, "ogr")
        flds = layer.fields()
        for field in flds:
            attr_struct.append([name, field.name(), field.typeName(), field.length()])
    
    return attr_struct


# 8. COMPARE ATTRIBUTE TABLES STRUCTURES
def attribute_table_check(inv_attr, temp_attr):
    fnm_errors = [] # errors in fields names
    missing_cols = [] # missing columns
    ftp_errors = [] # errors in fields types
    fln_errors = [] # errors in fields lengths
    
    temp_cols = []
    for temp in temp_attr:
        temp_cols.append(temp[:2])
        
    inv_cols = []
    for temp in inv_attr:
        inv_cols.append(temp[:2])
        
    for inv in inv_attr:
        for temp in temp_attr:
            if inv[0] == temp[0]: # if layer name the same
                if inv[:2] not in temp_cols and inv not in fnm_errors:
                    fnm_errors.append(inv)
                if temp[:2] not in inv_cols and temp not in missing_cols:
                    missing_cols.append(temp)
                
            if inv[:2] == temp[:2]: # layer and column names same
                if inv[2]!=temp[2] and inv not in ftp_errors:
                    ftp_errors.append(inv)
                if inv[3] != temp[3] and inv not in fln_errors: 
                    fln_errors.append(inv)
                    
    return [fnm_errors, missing_cols, ftp_errors, fln_errors]



###### SECTION 2 ######
# 9. LIST OF ALL PLANTS FROM CSV
def csv_to_list(plants_csv_path, encode):
    """READ CSV TO LIST"""
    plants_list = []
    with open(plants_csv_path, newline = "", encoding=encode) as f:
        reader = csv.reader(f)
        for row in reader:
            for i in row:
                parameters = i.split(';')
                plants_list.append(parameters)
    return plants_list


# 10. LIST OF SPECIES FROM CSV FILE
def species_from_csv(csv_table):
    """CREATE LIST OF SPECIES FROM CSV FILE"""
    spec_csv = []
    for i in csv_table:
        if i[3]=="":
            tmp=("{} {}".format(i[1],i[2])) # genere, specie
        else:
            tmp=("{} {} {}".format(i[1],i[2],i[3])) # genere, specie, varieta
        spec_csv.append(tmp.strip())
        
    return spec_csv


# 11. CODICE FROM LEGEND CSV
def codice_from_csv(legend_path, encode):
    codice_list = []
    with open(legend_path, newline = "", encoding=encode) as f:
        reader = csv.reader(f)
        for row in reader:
            codice_list.append(row[0][:7])
    
    return codice_list
    

# 12. ZONA+AREA FROM S3.SHP
def zarea_from_shp(temp_paths):
    za_list = []
    for path in temp_paths:
        if os.path.basename(path)[:-4] == "S3":
            lyr = QgsVectorLayer(path, "S3", "ogr")
            zona = lyr.fields().indexOf("zona")
            area = lyr.fields().indexOf("area")
            
            for ftr in lyr.getFeatures():
                za = "{}.{}".format(ftr[zona], ftr[area])
                if za not in za_list:
                    za_list.append(za)
    return za_list


# 13 OBJ_IS AND PT FROM P1 INV - TAKES TOO MUCH TIME
def pts_from_inv(path):
    pts_list = []
    ids_list = []

    lyr = QgsVectorLayer(path, "P1", "ogr")
    obj_id = lyr.fields().indexOf("obj_id")
    pt = lyr.fields().indexOf("pt")
    
    for ftr in lyr.getFeatures():
        if  pt != -1:
            pts_list.append([ftr[obj_id], ftr[pt]])
        else:
            pts_list.append([ftr[obj_id], []])
        ids_list.append(ftr[obj_id])
                
    return [ids_list, pts_list]


# 14. OBJ_IS AND PT FROM P1 TEMPL - TAKES TOO MUCH TIME
def pt_from_shp(temp_paths, name):
    objid_list = []
    pt_list = []
    for path in temp_paths:
        if os.path.basename(path)[:-4] == "{}".format(name):
            lyr = QgsVectorLayer(path, name, "ogr")
            obj_id = lyr.fields().indexOf("obj_id")
            pt = lyr.fields().indexOf("pt")
            
            for ftr in lyr.getFeatures():
                objid_list.append(ftr[obj_id])
                if  pt != -1:
                    pt_list.append([ftr[obj_id], ftr[pt]])
                else:
                    pt_list.append([ftr[obj_id], []])
                    
    return [objid_list, pt_list]
    
    
# 15. PTS VALIDATION - TAKES TOO MUCH TIME
def pt_valid(pts_inv, pts_shp):
    invalid_pts = []
    
    for pt in pts_inv:
        if pt not in pts_shp and pt[0] != 0 and pt not in invalid_pts:
            invalid_pts.append(pt[1])
            
    return invalid_pts
    
# 16. OBJ_IDS VALIDATION  - TAKES TOO MUCH TIME
def oid_valid(obj_ids_inv, obj_ids_shp):
    invalid_oid = []
    for oid in obj_ids_inv:
        if oid not in obj_ids_shp and oid != 0 and oid not in invalid_oid:
            invalid_oid.append(oid)
    
    repeated_oid = []
    for oid in obj_ids_inv:
        if oid != 0 and obj_ids_inv.count(oid) > 1 and oid not in repeated_oid:
            repeated_oid.append(oid)
            
    return [invalid_oid, repeated_oid]

# 17. P1 - REST PARAMETERS VALIDATION
def p1_validation(path, species_csv, codice_csv, zrea): #, obj_ids, pts):
    """P1 LAYER VALIDATION"""
    invalid_zrea = []
    invalid_ptps = []
    invalid_codice = []
    invalid_names = []
    invalid_h_m = []
    invalid_dtronc = []
    invalid_dchiom = []
    invalid_stato = []
    
    nm = os.path.basename(path)[:-4]
    layer = QgsVectorLayer(path, nm, "ogr")
    flds = layer.fields()
    
    if nm == "P1":
        zona = flds.indexOf("zona")
        area = flds.indexOf("area")
        tp =  flds.indexOf("tp")
        ts =  flds.indexOf("ts")
        codice =  flds.indexOf("codice")
        pt =  flds.indexOf("pt")
        genere =  flds.indexOf("genere")
        specie =  flds.indexOf("specie")
        varieta =  flds.indexOf("varieta")
        h_m =  flds.indexOf("h_m")
        diam_tronc =  flds.indexOf("diam_tronc")
        diam_chiom =  flds.indexOf("diam_chiom")
        stato =  flds.indexOf("stato")
        
        for ftr in layer.getFeatures():
            
            # ZONA & AREA
            if pt != -1 and zona != -1 and area != -1:
                ftr_nm = "{}: zona + area {}.{}".format(ftr[pt], ftr[zona], ftr[area])
                za = "{}.{}".format(ftr[zona], ftr[area])
                if za not in zrea:
                    invalid_zrea.append(ftr_nm)
            
            # TP, TS
            if pt != -1 and tp != -1 and ts != -1:
                ptps = "{}{}".format(ftr[tp], ftr[ts])
                ftr_nm = "pt {}: tp {}, ts {}".format(ftr[pt], ftr[tp], ftr[ts])
                if ptps != ftr[codice][1:4]:
                    invalid_ptps.append(ftr_nm)
            
            # SPECIES
            if pt != -1 and genere != -1 and specie != -1 and varieta != -1:
                if ftr[varieta] != NULL:
                    gsv = "{} {} {}".format(ftr[genere], ftr[specie], ftr[varieta])
                else:
                    gsv = "{} {}".format(ftr[genere], ftr[specie])
                    
                ftr_nm = "pt: {}, gatunek {}".format(ftr[pt], gsv)
                if gsv not in species_csv:
                    invalid_names.append(ftr_nm)
            
            # CODICE
            if pt != -1 and genere != -1 and specie != -1 and codice != -1:
                ftr_nm = "pt: {}, gatunek: {} {}, codice: {}".format(ftr[pt], ftr[genere], ftr[specie], ftr[codice])
                if ftr[codice] not in codice_csv or ftr[codice][:2] != nm:
                    invalid_codice.append(ftr_nm)
            
            # H_M
            if pt != -1 and h_m != -1:
                ranges = ["< 5", "5-10", "10-15", "15-20","20-25","25-30", "> 30"]
                ftr_nm = "pt: {}, h_m: {}".format(ftr[pt], ftr[h_m])
                if ftr[h_m] != NULL:
                    if ftr[h_m] not in ranges:
                        invalid_h_m.append(ftr_nm)
                
            # DIAM_TRONC
            if pt != -1 and diam_tronc != -1:
                av = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ";", "."]
                ftr_nm = "pt: {}, średnice pni: {}".format(ftr[pt], ftr[diam_tronc])
                if ftr[diam_tronc] != NULL:
                    for i in str(ftr[diam_tronc]):
                        if (i not in av and i is not None)and ftr_nm not in invalid_dtronc:
                            invalid_dtronc.append(ftr_nm)
                    
            # DIAM_CHIOM
            if pt != -1 and diam_chiom != -1:
                av = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "."]
                ftr_nm = "pt: {}, średnica korony: {}".format(ftr[pt], ftr[diam_chiom])
                if ftr[diam_chiom] != NULL:
                    for i in str(ftr[diam_chiom]):
                        if i not in av and ftr_nm not in invalid_dtronc:
                            invalid_dchiom.append(ftr_nm)
                
            # STATUS
            if pt != -1 and stato != -1:
                statuses = ["Drzewo martwe", \
                            "Drzewo niezarządzane", \
                            "Drzewo żywe", \
                            "Pniak", \
                            "Puste miejsce", \
                            "roślina usunięta", \
                            "roślina żywa"]
                
                ftr_nm = "pt: {}, status: {}".format(ftr[pt], ftr[stato])
                if ftr[stato] not in statuses:
                    invalid_stato.append(ftr_nm)


        if pt == -1 or zona == -1 or area == -1:
            invalid_zrea.append("brak wymaganej kolumny/kolumn do sprawdzenia")

        if pt == -1 or tp == -1 or ts == -1:
            invalid_ptps.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or genere == -1 or specie == -1 or varieta == -1:
            invalid_names.append("brak wymaganej kolumny/kolumn do sprawdzenia")
        
        if pt == -1 or genere == -1 or specie == -1 or codice == -1:
            invalid_codice.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or h_m == -1:
            invalid_h_m.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or diam_tronc == -1:
            invalid_dtronc.append("brak wymaganej kolumny/kolumn do sprawdzenia")

        if pt == -1 or diam_chiom == -1:
            invalid_dchiom.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or stato == -1:
            invalid_stato.append("brak wymaganej kolumny/kolumn do sprawdzenia")


    return [    invalid_zrea, invalid_ptps, invalid_codice, invalid_names, 
                invalid_h_m, invalid_dtronc, invalid_dchiom, invalid_stato]


# 18. L1/S1 - PARAMETERS VALIDATION
def l1_s1_validation(path, species_csv, codice_csv, zrea): #, obj_ids, pts):
    """P1 LAYER VALIDATION"""
    invalid_zrea = []
    invalid_ptps = []
    invalid_codice = []
    invalid_names = []
    invalid_stato = []
    
    nm = os.path.basename(path)[:-4]
    layer = QgsVectorLayer(path, nm, "ogr")
    flds = layer.fields()
    if nm == "L1" or nm == "S1":
        zona = flds.indexOf("zona")
        area = flds.indexOf("area")
        tp =  flds.indexOf("tp")
        ts =  flds.indexOf("ts")
        codice =  flds.indexOf("codice")
        pt =  flds.indexOf("pt")
        genere =  flds.indexOf("genere")
        specie =  flds.indexOf("specie")
        varieta =  flds.indexOf("varieta")
        stato =  flds.indexOf("stato")
        
        for ftr in layer.getFeatures():
            
            # ZONA & AREA
            if pt != -1 and zona != -1 and area != -1:
                ftr_nm = "pt: {}, zona+area: {}.{}".format(ftr[pt], ftr[zona], ftr[area])
                za = "{}.{}".format(ftr[zona], ftr[area])
                if za not in zrea:
                    invalid_zrea.append(ftr_nm)
            
            # TP, TS
            if tp != -1 and ts != -1:
                ptps = "{}{}".format(ftr[tp], ftr[ts])
                ftr_nm = "pt: {}, tp: {}, ts: {}".format(ftr[pt], ftr[tp], ftr[ts])
                if ptps != ftr[codice][1:4]:
                    invalid_ptps.append(ftr_nm)
            
            # SPECIES
            if genere != -1 and specie != -1 and varieta != -1 and pt != -1:
                if ftr[varieta] != NULL:
                    gsv = "{} {} {}".format(ftr[genere], ftr[specie], ftr[varieta])
                else:
                    gsv = "{} {}".format(ftr[genere], ftr[specie])
                    
                ftr_nm = "pt: {}, gatunek: {}".format(ftr[pt], gsv)
                if gsv not in species_csv:
                    invalid_names.append(ftr_nm)
            
            # CODICE
            if pt != -1 and genere != -1 and specie != -1 and codice != -1:
                ftr_nm = "pt: {}, gatunek: {} {}, codice: {}".format(ftr[pt], ftr[genere], ftr[specie], ftr[codice])
                if ftr[codice] not in codice_csv or ftr[codice][:2] != nm:
                    invalid_codice.append(ftr_nm)
              
            # STATUS
            if pt != -1 and stato != -1:
                if nm == "L1":
                    statuses = ["zywopłot_roślina_żywa", \
                                "żywopłot_roślina_martwa", \
                                "Krzew żywy", \
                                "Krzew martwy", \
                                "roślina żywa", \
                                "roślina martwa"]
                elif nm == "S1":
                    statuses =  [   "Drzewo żywe", \
                                    "drzewo żywe", \
                                    "Grupa drzew", \
                                    "Grupa krzewów",
                                    "Krzew żywy",
                                    "Pianta viva",
                                    "roślina żywa",
                                    "zywopłot_roślina_żywa"] 
                                
                ftr_nm = "pt: {}, status: {}".format(ftr[pt], ftr[stato])
                if ftr[stato] not in statuses:
                    invalid_stato.append(ftr_nm)
                    
        if pt == -1 or zona == -1 or area == -1:
            invalid_zrea.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if tp == -1 or ts == -1:
            invalid_ptps.append("brak wymaganej kolumny/kolumn do sprawdzenia")
        
        if genere == -1 or specie == -1 or varieta == -1 or pt == -1:
            invalid_names.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or genere == -1 or specie == -1 or codice == -1:
            invalid_codice.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or stato == -1:
            invalid_stato.append("brak wymaganej kolumny/kolumn do sprawdzenia")
        

    return [    invalid_zrea, invalid_ptps, invalid_codice, 
                invalid_names, invalid_stato]





# 19. P2 - REST PARAMETERS VALIDATION
def p2_validation(path, species_csv, codice_csv, zrea): #, obj_ids, pts):
    """P1 LAYER VALIDATION"""
    invalid_zrea = []
    invalid_ptps = []
    invalid_codice = []
    
    nm = os.path.basename(path)[:-4]
    layer = QgsVectorLayer(path, nm, "ogr")
    flds = layer.fields()
    
    if nm == "P2":
        zona = flds.indexOf("zona")
        area = flds.indexOf("area")
        tp =  flds.indexOf("tp")
        ts =  flds.indexOf("ts")
        codice =  flds.indexOf("codice")
        pt =  flds.indexOf("pt")
        
        for ftr in layer.getFeatures():
            
            # ZONA & AREA
            if pt != -1 and zona != -1 and area != -1:
                ftr_nm = "{}: {}.{}".format(ftr[pt], ftr[zona], ftr[area])
                za = "{}.{}".format(ftr[zona], ftr[area])
                if za not in zrea:
                    invalid_zrea.append(ftr_nm)
            
            # TP, TS
            if pt != -1 and tp != -1 and ts != -1:
                ptps = "{}{}".format(ftr[tp], ftr[ts])
                ftr_nm = "pt: {}, tp: {}, ts: {}".format(ftr[pt], ftr[tp], ftr[ts])
                if ptps != ftr[codice][1:4]:
                    invalid_ptps.append(ftr_nm)
            
            # CODICE
            if pt != -1 and codice != -1:
                ftr_nm = "pt: {}, codice: {}".format(ftr[pt], ftr[codice])
                if ftr[codice] not in codice_csv or ftr[codice][:2] != nm:
                    invalid_codice.append(ftr_nm)
        
        
        if pt == -1 or zona == -1 or area == -1:
            invalid_zrea.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 or tp == -1 or ts == -1:
            invalid_ptps.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if pt == -1 and codice == -1:
            invalid_codice.append("brak wymaganej kolumny/kolumn do sprawdzenia")
        
            
    return [invalid_zrea, invalid_ptps, invalid_codice]



# 20. L2/S2 - REST PARAMETERS VALIDATION
def l2_s2_validation(path, species_csv, codice_csv, zrea): #, obj_ids, pts):
    """P1 LAYER VALIDATION"""
    invalid_zrea = []
    invalid_ptps = []
    invalid_codice = []
    
    nm = os.path.basename(path)[:-4]
    layer = QgsVectorLayer(path, nm, "ogr")
    flds = layer.fields()
    
    if nm == "L2" or nm == "S2":
        zona = flds.indexOf("zona")
        area = flds.indexOf("area")
        tp =  flds.indexOf("tp")
        ts =  flds.indexOf("ts")
        codice =  flds.indexOf("codice")
        
        for ftr in layer.getFeatures():
            
            # ZONA & AREA
            if zona != -1 and area != -1:
                ftr_nm = "zona+area: {}.{}".format(ftr[zona], ftr[area])
                za = "{}.{}".format(ftr[zona], ftr[area])
                if za not in zrea:
                    invalid_zrea.append(ftr_nm)
            
            # TP, TS
            if tp != -1 and ts != -1:
                ptps = "{}{}".format(ftr[tp], ftr[ts])
                ftr_nm = "tp: {}, ts: {}".format(ftr[tp], ftr[ts])
                if ptps != ftr[codice][1:4]:
                    invalid_ptps.append(ftr_nm)
            
            # CODICE
            if codice != -1:
                ftr_nm = "codice: {}".format(ftr[codice])
                if ftr[codice] not in codice_csv or ftr[codice][:2] != nm:
                    invalid_codice.append(ftr_nm)
        
        
        if zona == -1 or area == -1:
            invalid_zrea.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if tp == -1 or ts == -1:
            invalid_ptps.append("brak wymaganej kolumny/kolumn do sprawdzenia")
            
        if codice == -1:
            invalid_codice.append("brak wymaganej kolumny/kolumn do sprawdzenia")
        
            
    return [invalid_zrea, invalid_ptps, invalid_codice]






class InventoryValidator:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'InventoryValidator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Sprawdzenie poprawności inwentaryzacji')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('InventoryValidator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/inventory_validator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Sprawdzenie poprawności inwentaryzacji'),
                action)
            self.iface.removeToolBarIcon(action)


    
    def clear_leds(self):
        self.dlg.led_inv.clear()
        self.dlg.led_plants.clear()
        self.dlg.led_legend.clear()
        self.dlg.led_p1.clear()
        self.dlg.led_l1.clear()
        self.dlg.led_s1.clear()
        self.dlg.led_p2.clear()
        self.dlg.led_l2.clear()
        self.dlg.led_s2.clear()
        self.dlg.led_s3.clear()
        self.dlg.led_gs.clear()
        
        self.dlg.inv_paths = []
        self.dlg.temp_paths = []
        self.dlg.plants_path = ""
        self.dlg.legend_path = ""
        
    
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = InventoryValidatorDialog()
            
            # ADDED BY LS
            self.dlg.ted_note.setReadOnly(True)
            
            self.dlg.btn_inv.clicked.connect(self.evt_btn_inv_clicked)
#            self.dlg.btn_temp.clicked.connect(self.evt_btn_temp_clicked)
            self.dlg.btn_gs.clicked.connect(self.evt_btn_gs_clicked)
            self.dlg.btn_p1.clicked.connect(self.evt_btn_p1_clicked)
            self.dlg.btn_l1.clicked.connect(self.evt_btn_l1_clicked)
            self.dlg.btn_s1.clicked.connect(self.evt_btn_s1_clicked)
            self.dlg.btn_p2.clicked.connect(self.evt_btn_p2_clicked)
            self.dlg.btn_l2.clicked.connect(self.evt_btn_l2_clicked)
            self.dlg.btn_s2.clicked.connect(self.evt_btn_s2_clicked)
            self.dlg.btn_s3.clicked.connect(self.evt_btn_s3_clicked)
            self.dlg.btn_plants.clicked.connect(self.evt_btn_plants_clicked)
            self.dlg.btn_legend.clicked.connect(self.evt_btn_legend_clicked)
            
            self.dlg.btn_calc.clicked.connect(self.evt_btn_calc_clicked)
            self.dlg.btn_cancel.clicked.connect(self.evt_btn_cancel_clicked)
            
        self.dlg.show()
        self.clear_leds()


    # ADDED BY LS  
    def evt_btn_inv_clicked(self):
        zip_fn, fn_ok = QFileDialog.getOpenFileNames(self.dlg,
                            "Inwentaryzacja do sprawdzenia",
                            os.path.abspath(r""),"Pliki Shape File (*.shp);")

        if fn_ok:
            self.dlg.inv_paths = zip_fn
            catalog = zip_fn[0].replace(os.path.basename(zip_fn[0]),"") + "*"
            self.dlg.led_inv.setText(catalog)


#    def evt_btn_temp_clicked(self):
#        zip_fn, fn_ok = QFileDialog.getOpenFileNames(self.dlg,
#                            "Szablon/Zasób GREENSPACES",
#                            os.path.abspath(r""),"Pliki Shape File (*.shp);")
#
#        if fn_ok:
##            self.dlg.temp_paths = zip_fn
#            catalog = zip_fn[0].replace(os.path.basename(zip_fn[0]),"") + "*"
#            self.dlg.led_temp.setText(catalog)
            
    def evt_btn_gs_clicked(self):
        gs_fn = QFileDialog.getExistingDirectory(self.dlg,
                    "Szablon/Zasób GREENSPACES",
                    os.path.abspath(r""))

        for path in glob.glob('{}/*.shp'.format(gs_fn)):
            self.dlg.temp_paths.append(path)
            self.dlg.led_gs.setText(gs_fn + "\\*")
            
            if os.path.basename(path) == "P1.shp":
                self.dlg.led_p1.setText(path)
            elif os.path.basename(path) == "L1.shp":
                self.dlg.led_l1.setText(path)
            elif os.path.basename(path) == "S1.shp":
                self.dlg.led_s1.setText(path)
            elif os.path.basename(path) == "P2.shp":
                self.dlg.led_p2.setText(path)
            elif os.path.basename(path) == "L2.shp":
                self.dlg.led_l2.setText(path)
            elif os.path.basename(path) == "S2.shp":
                self.dlg.led_s2.setText(path)
            elif os.path.basename(path) == "S3.shp":
                self.dlg.led_s3.setText(path)
            
        for path in glob.glob('{}/*.csv'.format(gs_fn)):
            if os.path.basename(path) == "Legenda.csv":
                self.dlg.legend_path = path
                self.dlg.led_legend.setText(self.dlg.legend_path)
                
            if os.path.basename(path) == "Nazwy roślin.csv":
                self.dlg.plants_path = path
                self.dlg.led_plants.setText(self.dlg.plants_path)


    def evt_btn_p1_clicked(self):
        shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj szablon P1.shp",
                            os.path.abspath(r""), "Plik shp (*.shp);")

        if fn_ok:
            self.dlg.led_p1.setText(shp_fn)
            
            
    def evt_btn_l1_clicked(self):
        shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj szablon L1.shp",
                            os.path.abspath(r""), "Plik shp (*.shp);")

        if fn_ok:
            self.dlg.led_l1.setText(shp_fn)
            
            
    def evt_btn_s1_clicked(self):
        shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj szablon S1.shp",
                            os.path.abspath(r""), "Plik shp (*.shp);")

        if fn_ok:
            self.dlg.led_s1.setText(shp_fn)


    def evt_btn_p2_clicked(self):
        shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj szablon P2.shp",
                            os.path.abspath(r""), "Plik shp (*.shp);")

        if fn_ok:
            self.dlg.led_p2.setText(shp_fn)
            
            
    def evt_btn_l2_clicked(self):
            shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                                "Wczytaj szablon L2.shp",
                                os.path.abspath(r""), "Plik shp (*.shp);")
            if fn_ok:
                self.dlg.led_l2.setText(shp_fn)
                
                
    def evt_btn_s2_clicked(self):
            shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                                "Wczytaj szablon S2.shp",
                                os.path.abspath(r""), "Plik shp (*.shp);")
            if fn_ok:
                self.dlg.led_s2.setText(shp_fn)
                
                
    def evt_btn_s3_clicked(self):
        shp_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj szablon S3.shp",
                            os.path.abspath(r""), "Plik shp (*.shp);")
        if fn_ok:
            self.dlg.led_s3.setText(shp_fn)


    def evt_btn_plants_clicked(self):
        csv_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj plik z nazwami roślin",
                            os.path.abspath(r""), "Plik csv (*.csv);")

        if fn_ok:
            self.dlg.plants_path = csv_fn
            self.dlg.led_plants.setText(csv_fn)


    def evt_btn_legend_clicked(self):
        csv_fn, fn_ok = QFileDialog.getOpenFileName(self.dlg, 
                            "Wczytaj plik z kodami CODICE",
                            os.path.abspath(r""), "Plik csv (*.csv);")

        if fn_ok:
            self.dlg.legend_path = csv_fn
            self.dlg.led_legend.setText(csv_fn)


    def evt_btn_cancel_clicked(self):
        self.dlg.close()
        
    def evt_btn_calc_clicked(self):
        self.dlg.temp_paths = []
        
        p1_path = self.dlg.led_p1.text()
        l1_path = self.dlg.led_l1.text()
        s1_path = self.dlg.led_s1.text()
        p2_path = self.dlg.led_p2.text()
        l2_path = self.dlg.led_l2.text()
        s2_path = self.dlg.led_s2.text()
        s3_path = self.dlg.led_s3.text()
        
        if os.path.isfile(p1_path):
            self.dlg.temp_paths.append(p1_path)
        if os.path.isfile(l1_path):
            self.dlg.temp_paths.append(l1_path)
        if os.path.isfile(s1_path):
            self.dlg.temp_paths.append(s1_path)
        if os.path.isfile(p2_path):
            self.dlg.temp_paths.append(p2_path)
        if os.path.isfile(l2_path):
            self.dlg.temp_paths.append(l2_path)
        if os.path.isfile(s2_path):
            self.dlg.temp_paths.append(s2_path)
        if os.path.isfile(s3_path):
            self.dlg.temp_paths.append(s3_path)
        
        inv_fns = fns_from_paths(self.dlg.inv_paths)
        temp_fns = fns_from_paths(self.dlg.temp_paths)
        check_fns = fns_from_paths(self.dlg.inv_paths)
        
        err_msg = ""
        if "P1" in check_fns and "P1" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: P1.shp\n"
        if "P2" in check_fns and "P2" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: P2.shp\n"
        if "L1" in check_fns and "L1" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: L1.shp\n"
        if "L2" in check_fns and "L2" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: L2.shp\n"
        if "S1" in check_fns and "S1" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: S1.shp\n"
        if "S2" in check_fns and "S2" not in temp_fns:
            err_msg += "Nie wczytano szablonu dla sprawdzanej warstwy: S2.shp\n"
        if "S3" not in temp_fns:
            err_msg += "Nie wczytano wymaganego szablonu: S3.shp\n"
        if not os.path.isfile(self.dlg.plants_path):
            err_msg += "Nie wczytano wymaganego szablonu: Nazwy_roslin.csv\n"
        if not os.path.isfile(self.dlg.legend_path):
            err_msg += "Nie wczytano wymaganego szablonu: Legenda.csv"
            
        if len(inv_fns) == 0:
            QMessageBox.information(self.dlg, "BŁĄD", "Nie wczytano plików do sprawdzenia")
        elif err_msg != "":
            QMessageBox.information(self.dlg, "BŁĄD", err_msg)
        else:
            self.dlg_errors = DlgErrors()
            self.dlg_errors.setModal(True)
            self.dlg_errors.start = time.time()
            self.dlg_errors.setWindowTitle("SPRAWDZANIE POPRAWNOŚCI INWENTARYZACJI")
            self.dlg_errors.ted_errors.setPlainText("Obliczenia w trakcie, proces może zająć kilka minut....")
            self.dlg_errors.ted_errors.setReadOnly(True)
            
            self.dlg_errors.timer = QtCore.QTimer()
            self.dlg_errors.timer.setSingleShot(True)
            self.dlg_errors.timer.setInterval(100)
            self.dlg_errors.timer.timeout.connect(self.evt_timer_timeout)
            
            self.dlg_errors.show()
            self.dlg_errors.timer.start()
            self.dlg_errors.exec_()


    def evt_timer_timeout(self):
        msg = ""

        # 4. LISTS WITH FILES NAMES (P1, P2, ...)
        inv_fns = fns_from_paths(self.dlg.inv_paths)
        templ_fns = fns_from_paths(self.dlg.temp_paths)
        msg += "-" * 80
        msg += "\nSPRAWDZONE PLIKI:\n"
        for path in self.dlg.inv_paths:
            msg += "{}\n".format(path)
        
        """ COMPARISON """
        # 5. COMPARE LAYERS NAMES WITH TEMPLATES
        name_errors = names_check(inv_fns, templ_fns)          
        
        if len(name_errors) > 0:
            # 6. DELETE PATHS TO FILES WITH WRONG NAMES
            self.dlg.inv_paths = remove_wrong_paths(self.dlg.inv_paths, name_errors)
            msg += "-" * 80
            msg += "\nNIEWŁAŚCIWE NAZWY PLIKÓW (warstwy nieobjęte dalszym sprawdzeniem):\n"
            for err in name_errors:
                msg +="\t{}\n".format(err)
        
        # 7. LIST 2D WITH FIELDS PARAMETERS FROM TOC
        inv_attr = attribute_table_structure(self.dlg.inv_paths)
        temp_attr = attribute_table_structure(self.dlg.temp_paths)
    
        # 8. COMPARE ATTRIBUTE TABLES STRUCTURES 
        fnm_errors = attribute_table_check(inv_attr, temp_attr)[0] # errors in fields names
        missing_cols = attribute_table_check(inv_attr, temp_attr)[1] # missing columns
        ftp_errors = attribute_table_check(inv_attr, temp_attr)[2] # errors in fields types
        fln_errors = attribute_table_check(inv_attr, temp_attr)[3] # errors in fields lengths


        if len(fnm_errors) != 0 or len(missing_cols) != 0 or \
        len(ftp_errors) != 0 or len(fln_errors) != 0:
            
            msg += "-" * 80
            msg += "\nBŁĘDY W STRUKTURZE TABELI ATRYBUTÓW:\n"
            
            if len(fnm_errors) > 0:
                msg += "- błędne nazwy kolumn:\n"
                for err in fnm_errors:
                    txt =""
                    for i in err:
                        txt += "{} ".format(i)
                    msg += "\t{}\n".format(txt)
                
            if len(missing_cols) > 0:
                msg += "- brak kolumn:\n"
                for err in missing_cols:
                    txt =""
                    for i in err:
                        txt += "{} ".format(i)
                    msg += "\t{}\n".format(txt)
                
            if len(ftp_errors) > 0:
                msg += "- błędne typy kolumn:\n"
                for err in ftp_errors:
                    txt =""
                    for i in err:
                        txt += "{} ".format(i)
                    msg += "\t{}\n".format(txt)
            
            if len(fln_errors) > 0:
                msg += "- błędne długości kolumn:\n"
                for err in fln_errors:
                    txt =""
                    for i in err:
                        txt += "{} ".format(i)
                    msg += "\t{}\n".format(txt)
        
        else:
            msg += "-" * 80
            msg += "\nSTRUKTURA TABELI ATRYBUTÓW POPRAWNA:\n"
        
        try:
            encode = self.dlg.cmb_encode.currentText()
            # 9. CREATE COMPLETE LIST OF ALL PLANTS FROM CSV
            csv_table = csv_to_list(self.dlg.plants_path, encode=encode)
        except:
            QMessageBox.information(self.dlg, "Błąd wczytywanie pliku csv", "Spróbuj zmienić kodowanie")
            self.dlg_errors.close()
            csv_table = False
            
        if csv_table:
            # 10. LIST OF SPECIES FROM CSV FILE
            species_csv = species_from_csv(csv_table)
            # 11. CODICE FROM LEGEND CSV
            codice_csv = codice_from_csv(self.dlg.legend_path, encode=encode)

            # 12. A ZONA+AREA FROM S3.SHP
            zrea = zarea_from_shp(self.dlg.temp_paths)
            
            ##############################################33
            
    #        # 13 OBJ_IS AND PT FROM P1 INV  - TAKES TOO MUCH TIME
    #        obj_ids_inv = pts_from_inv(self.dlg.inv_paths)[0]
    #        pts_inv = pts_from_inv(self.dlg.inv_paths)[1]
    #        
    #        # 14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
    #        obj_ids_shp = pt_from_shp(self.dlg.temp_paths)[0]
    #        pts_shp = pt_from_shp(self.dlg.temp_paths)[1]
    #        
    #        """ COMPARISON """
    #        # 15. PTS VALIDATION  - TAKES TOO MUCH TIME
    #        p1_invalid_pts = pt_valid(pts_inv, pts_shp)
    #        
    #        """ COMPARISON """
    #        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
    #        p1_invalid_objid = oid_valid(obj_ids_inv, obj_ids_shp) 

            ##################################################

            """ COMPARISON """
            # 17. P1 - REST PARAMETERS VALIDATION
            for path in self.dlg.inv_paths:
                nm = os.path.basename(path)[:-4]
                if nm == "P1":
                    p1_invalid_zrea = p1_validation(path, species_csv, codice_csv, zrea)[0]
                    p1_invalid_ptps = p1_validation(path, species_csv, codice_csv, zrea)[1]
                    p1_invalid_codices = p1_validation(path, species_csv, codice_csv, zrea)[2]
                    p1_invalid_names = p1_validation(path, species_csv, codice_csv, zrea)[3]
                    p1_invalid_hm = p1_validation(path, species_csv, codice_csv, zrea)[4]
                    p1_invalid_dtronc = p1_validation(path, species_csv, codice_csv, zrea)[5]
                    p1_invalid_dchiom = p1_validation(path, species_csv, codice_csv, zrea)[6]
                    p1_invalid_stato = p1_validation(path, species_csv, codice_csv, zrea)[7]

                    # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv, pts_inv = pts_from_inv(path)
                        obj_ids_shp, pts_shp = pt_from_shp(self.dlg.temp_paths, name="P1")
    #                    pts_inv = pts_from_inv(path)[1]
    #                    pts_shp = pt_from_shp(self.dlg.temp_paths)[1]
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        p1_invalid_objid, p1_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        p1_invalid_objid = []
                        p1_repeated_objid = []
                        
                    if self.dlg.chk_pt.isChecked():
                        """ COMPARISON """
                        # 15. PTS VALIDATION  - TAKES TOO MUCH TIME
                        p1_invalid_pts = pt_valid(pts_inv, pts_shp)
                    else:
                        p1_invalid_pts = []
                    
                    if len(p1_invalid_zrea) == 0 and len(p1_invalid_ptps) == 0 and \
                    len(p1_invalid_codices) == 0 and len(p1_invalid_names) == 0 and \
                    len(p1_invalid_hm) == 0 and len(p1_invalid_dtronc) == 0 and \
                    len(p1_invalid_dchiom) == 0 and len(p1_invalid_stato) == 0 and \
                    len(p1_invalid_pts) ==0 and len(p1_invalid_objid) == 0 and \
                    len(p1_repeated_objid) == 0:
                        msg += "-" * 80
                        msg += "\nP1 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nP1 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(p1_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in p1_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(p1_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in p1_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(p1_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in p1_repeated_objid:
                                msg += "\t{}\n".format(i)
                        
                        if len(p1_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in p1_invalid_ptps:
                                msg += "\t{}\n".format(i)
                            
                        if len(p1_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in p1_invalid_codices:
                                msg += "\t{}\n".format(i)
                                
                        if len(p1_invalid_pts) > 0:
                            msg += "- zmienione pt wględem obj_id (niekoniecznie jest to błąd):\n"
                            for i in p1_invalid_pts:
                                msg += "\t{}\n".format(i)
     
                        if len(p1_invalid_names) > 0:
                            msg += "- błędy w nazwach gatunków:\n"
                            for i in p1_invalid_names:
                                msg += "\t{}\n".format(i)
                        
                        if len(p1_invalid_hm) > 0:
                            msg += "- błędy w wysokościach:\n"
                            for i in p1_invalid_hm:
                                msg += "\t{}\n".format(i)
                                
                        if len(p1_invalid_dtronc) > 0:
                            msg += "- błędy w średnicach pni:\n"
                            for i in p1_invalid_dtronc:
                                msg += "\t{}\n".format(i)
                        
                        if len(p1_invalid_stato) > 0:
                            msg += "- błędy w statusie rośliny:\n"
                            for i in p1_invalid_stato:
                                msg += "\t{}\n".format(i)
                        
                        
                # 18. L1 - REST PARAMETERS VALIDATION
                elif nm == "L1":
                    l1_invalid_zrea = l1_s1_validation(path, species_csv, codice_csv, zrea)[0]
                    l1_invalid_ptps = l1_s1_validation(path, species_csv, codice_csv, zrea)[1]
                    l1_invalid_codices = l1_s1_validation(path, species_csv, codice_csv, zrea)[2]
                    l1_invalid_names = l1_s1_validation(path, species_csv, codice_csv, zrea)[3]
                    l1_invalid_stato = l1_s1_validation(path, species_csv, codice_csv, zrea)[4]
                    
                    
                    # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv, pts_inv = pts_from_inv(path)
                        obj_ids_shp, pts_shp = pt_from_shp(self.dlg.temp_paths, name="L1")
    #                    pts_inv = pts_from_inv(path)[1]
    #                    pts_shp = pt_from_shp(self.dlg.temp_paths)[1]
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        l1_invalid_objid, l1_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        l1_invalid_objid = []
                        l1_repeated_objid = []
                        
                    if self.dlg.chk_pt.isChecked():
                        """ COMPARISON """
                        # 15. PTS VALIDATION  - TAKES TOO MUCH TIME
                        l1_invalid_pts = pt_valid(pts_inv, pts_shp)
                    else:
                        l1_invalid_pts = []
                    
                    
                    if len(l1_invalid_zrea) == 0 and len(l1_invalid_ptps) == 0 and \
                    len(l1_invalid_codices) == 0 and len(l1_invalid_names) == 0 and \
                    len(l1_invalid_stato) == 0 and len(l1_invalid_pts) == 0 and \
                    len(l1_repeated_objid) == 0 and len(l1_invalid_objid) == 0:
                        msg += "-" * 80
                        msg += "\nL1 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nL1 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(l1_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in l1_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(l1_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in l1_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(l1_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in l1_repeated_objid:
                                msg += "\t{}\n".format(i)
                        
                        if len(l1_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in l1_invalid_ptps:
                                msg += "\t{}\n".format(i)
                                
                        if len(l1_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in l1_invalid_codices:
                                msg += "\t{}\n".format(i)
                        
                        if len(l1_invalid_pts) > 0:
                            msg += "- zmienione pt wględem obj_id (niekoniecznie jest to błąd):\n"
                            for i in l1_invalid_pts:
                                msg += "\t{}\n".format(i)
                        
                        if len(l1_invalid_names) > 0:
                            msg += "- błędy w nazwach gatunków:\n"
                            for i in l1_invalid_names:
                                msg += "\t{}\n".format(i)
                                
                        if len(l1_invalid_stato) > 0:
                            msg += "- błędy w statusie rośliny:\n"
                            for i in l1_invalid_stato:
                                msg += "\t{}\n".format(i)
               
               
                # 18. S1 - REST PARAMETERS VALIDATION
                elif nm == "S1":
                    s1_invalid_zrea = l1_s1_validation(path, species_csv, codice_csv, zrea)[0]
                    s1_invalid_ptps = l1_s1_validation(path, species_csv, codice_csv, zrea)[1]
                    s1_invalid_codices = l1_s1_validation(path, species_csv, codice_csv, zrea)[2]
                    s1_invalid_names = l1_s1_validation(path, species_csv, codice_csv, zrea)[3]
                    s1_invalid_stato = l1_s1_validation(path, species_csv, codice_csv, zrea)[4]

                    # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv, pts_inv = pts_from_inv(path)
                        obj_ids_shp, pts_shp = pt_from_shp(self.dlg.temp_paths, name="S1")
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        s1_invalid_objid, s1_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        s1_invalid_objid = []
                        s1_repeated_objid = []
                        
                    if self.dlg.chk_pt.isChecked():
                        """ COMPARISON """
                        # 15. PTS VALIDATION  - TAKES TOO MUCH TIME
                        s1_invalid_pts = pt_valid(pts_inv, pts_shp)
                    else:
                        s1_invalid_pts = []


                    if len(s1_invalid_zrea) == 0 and len(s1_invalid_ptps) == 0 and \
                    len(s1_invalid_codices) == 0 and len(s1_invalid_names) == 0 and \
                    len(s1_invalid_stato) == 0 and len(s1_invalid_pts) == 0 and \
                    len(s1_repeated_objid) == 0 and len(s1_invalid_objid) == 0:
                        msg += "-" * 80
                        msg += "\nS1 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nS1 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(s1_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in s1_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in s1_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in s1_repeated_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in s1_invalid_ptps:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in s1_invalid_codices:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_pts) > 0:
                            msg += "- zmienione pt wględem obj_id (niekoniecznie jest to błąd):\n"
                            for i in s1_invalid_pts:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_names) > 0:
                            msg += "- błędy w nazwach gatunków:\n"
                            for i in s1_invalid_names:
                                msg += "\t{}\n".format(i)
                                
                        if len(s1_invalid_stato) > 0:
                            msg += "- błędy w statusie rośliny:\n"
                            for i in s1_invalid_stato:
                                msg += "\t{}\n".format(i)
            
            
                # 19. P2 - REST PARAMETERS VALIDATION
                elif nm == "P2":
                    p2_invalid_zrea = p2_validation(path, species_csv, codice_csv, zrea)[0]
                    p2_invalid_ptps = p2_validation(path, species_csv, codice_csv, zrea)[1]
                    p2_invalid_codices = p2_validation(path, species_csv, codice_csv, zrea)[2]
                    
                    # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv, pts_inv = pts_from_inv(path)
                        obj_ids_shp, pts_shp = pt_from_shp(self.dlg.temp_paths, name="P2")
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        p2_invalid_objid, p2_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        p2_invalid_objid = []
                        p2_repeated_objid = []
                        
                    if self.dlg.chk_pt.isChecked():
                        """ COMPARISON """
                        # 15. PTS VALIDATION  - TAKES TOO MUCH TIME
                        p2_invalid_pts = pt_valid(pts_inv, pts_shp)
                    else:
                        p2_invalid_pts = []
                    
                    
                    if len(p2_invalid_zrea) == 0 and len(p2_invalid_ptps) == 0 and \
                    len(p2_invalid_codices) == 0 and len(p2_invalid_pts) and \
                    len(p2_repeated_objid) and len(p2_invalid_objid):
                        msg += "-" * 80
                        msg += "\nP2 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nP2 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(p2_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in p2_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(p2_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in p2_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(p2_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in p2_repeated_objid:
                                msg += "\t{}\n".format(i)
                            
                        if len(p2_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in p2_invalid_ptps:
                                msg += "\t{}\n".format(i)
                                
                        if len(p2_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in p2_invalid_codices:
                                msg += "\t{}\n".format(i)
                                
                        if len(p2_invalid_pts) > 0:
                            msg += "- zmienione pt wględem obj_id (niekoniecznie jest to błąd):\n"
                            for i in p2_invalid_pts:
                                msg += "\t{}\n".format(i)
                    
                   
                # 20. L2 - REST PARAMETERS VALIDATION
                elif nm == "L2":
                    l2_invalid_zrea = l2_s2_validation(path, species_csv, codice_csv, zrea)[0]
                    l2_invalid_ptps = l2_s2_validation(path, species_csv, codice_csv, zrea)[1]
                    l2_invalid_codices = l2_s2_validation(path, species_csv, codice_csv, zrea)[2]
                    
                      # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv = pts_from_inv(path)[0]
                        obj_ids_shp = pt_from_shp(self.dlg.temp_paths, name="L2")[0]
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        l2_invalid_objid, l2_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        l2_invalid_objid = []
                        l2_repeated_objid = []
                    
                    if len(l2_invalid_zrea) == 0 and len(l2_invalid_ptps) == 0 and \
                    len(l2_invalid_codices) == 0 and len(l2_invalid_objid) == 0 and \
                    len(l2_repeated_objid) == 0:
                        msg += "-" * 80
                        msg += "\nL2 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nL2 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(l2_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in l2_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(l2_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in l2_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(l2_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in l2_repeated_objid:
                                msg += "\t{}\n".format(i)
                        
                        if len(l2_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in l2_invalid_ptps:
                                msg += "\t{}\n".format(i)
                        
                        if len(l2_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in l2_invalid_codices:
                                msg += "\t{}\n".format(i)
                    
                
                # 20. S2 - REST PARAMETERS VALIDATION
                elif nm == "S2":
                    s2_invalid_zrea = l2_s2_validation(path, species_csv, codice_csv, zrea)[0]
                    s2_invalid_ptps = l2_s2_validation(path, species_csv, codice_csv, zrea)[1]
                    s2_invalid_codices = l2_s2_validation(path, species_csv, codice_csv, zrea)[2]
                    
                    # 13 +14 OBJ_IS AND PT FROM P1  - TAKES TOO MUCH TIME
                    if self.dlg.chk_oid.isChecked() or self.dlg.chk_pt.isChecked():
                        obj_ids_inv = pts_from_inv(path)[0]
                        obj_ids_shp = pt_from_shp(self.dlg.temp_paths, name="S2")[0]
                    
                    if self.dlg.chk_oid.isChecked():
                        """ COMPARISON """
                        # 16. PTS VALIDATION  - TAKES TOO MUCH TIME
                        s2_invalid_objid, s2_repeated_objid = oid_valid(obj_ids_inv, obj_ids_shp)
                    else:
                        s2_invalid_objid = []
                        s2_repeated_objid = []
                    
                    if len(s2_invalid_zrea) == 0 and len(s2_invalid_ptps) == 0 and \
                    len(s2_invalid_codices) == 0 and len(s2_invalid_objid) == 0 and \
                    len(s2_repeated_objid) == 0:
                        msg += "-" * 80
                        msg += "\nS2 - WARSTWA POPRAWNA.\n"
                    else:
                        msg += "-" * 80
                        msg += "\nS2 - BŁĘDNIE WYPEŁNIONE DANE:\n"
                        
                        if len(s2_invalid_zrea) > 0:
                            msg += "- błędy w zona i area:\n"
                            for i in s2_invalid_zrea:
                                msg += "\t{}\n".format(i)
                                
                        if len(s2_invalid_objid) > 0:
                            msg += "- błędy w obj_id (brak obj_id w bazie GS):\n"
                            for i in s2_invalid_objid:
                                msg += "\t{}\n".format(i)
                                
                        if len(s2_repeated_objid) > 0:
                            msg += "- powtórzenia obj_id:\n"
                            for i in s2_repeated_objid:
                                msg += "\t{}\n".format(i)
                        
                        if len(s2_invalid_ptps) > 0:
                            msg += "- błędy w pt i ts:\n"
                            for i in s2_invalid_ptps:
                                msg += "\t{}\n".format(i)
                        
                        if len(s2_invalid_codices) > 0:
                            msg += "- błędy w codice:\n"
                            for i in s2_invalid_codices:
                                msg += "\t{}\n".format(i)
                        msg += "-" * 80
                        
            self.dlg_errors.stop = time.time()
            
            self.dlg_errors.setWindowTitle("WYNIK SPRAWDZENIA (przeliczono w {} sek)"\
                            .format(round(self.dlg_errors.stop - self.dlg_errors.start)))
            
            self.dlg_errors.ted_errors.setPlainText(msg)
#            self.clear_leds()
            self.dlg_errors.exec_()
        

